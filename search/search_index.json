{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u0426\u0438\u043c\u0438\u043d\u0442\u0438\u044f \u041d\u0438\u043a\u043e\u043b\u0430\u0439 K33392","title":"Home"},{"location":"#k33392","text":"","title":"\u0426\u0438\u043c\u0438\u043d\u0442\u0438\u044f \u041d\u0438\u043a\u043e\u043b\u0430\u0439 K33392"},{"location":"lab_1/","text":"\u0412 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0430 \u0434\u043b\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043c\u043d\u043e\u044e \u0431\u044b\u043b\u0430 \u0432\u044b\u0431\u0440\u0430\u043d\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u0434\u043b\u044f \u0431\u0443\u043a\u043a\u0440\u043e\u0441\u0441\u0438\u043d\u0433\u0430 \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u041c\u0438\u0433\u0440\u0430\u0446\u0438\u0438 \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 \u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b func (s *Server) RegisterUser(c *gin.Context) { login := c.Query(\"login\") password := c.Query(\"password\") err := s.storage.CreateUser(login, password) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatus(http.StatusOK) } func (s *Server) AuthUser(c *gin.Context) { login := c.Query(\"login\") password := c.Query(\"password\") res, err := s.storage.AuthUser(login, password) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } if res { token, err := s.tokenator.Generate(login) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatusJSON(http.StatusOK, gin.H{\"token\": token}) return } else { c.AbortWithStatusJSON(http.StatusBadRequest, helpers.NewJSONErr(errs.WrongCredentials)) return } } func (s *Server) AuthMW(c *gin.Context) { token := c.GetHeader(\"token\") res, login := s.tokenator.Check(token) if res { c.AddParam(\"login\", login) c.Next() } else { c.AbortWithStatus(http.StatusUnauthorized) return } } package handlers import ( \"books/internal/api/helpers\" \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\" \"strconv\" ) func (h *Handler) CreateBook(c *gin.Context) { author := c.Query(\"author\") name := c.Query(\"name\") err := h.storage.CreateBook(author, name) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatus(http.StatusOK) } func (h *Handler) GetBooks(c *gin.Context) { res, err := h.storage.GetBooks() if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.IndentedJSON(http.StatusOK, res) } func (h *Handler) AddBookToLib(c *gin.Context) { user := c.Query(\"login\") bookStr := c.Query(\"bookID\") bookID, _ := strconv.Atoi(bookStr) fmt.Println(\"book id: \", bookID) err := h.storage.AddBookToLib(user, bookID) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatus(http.StatusOK) } func (h *Handler) GetUserLib(c *gin.Context) { user := c.Query(\"user\") userModel, err := h.storage.GetUser(user) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } books, err := h.storage.GetLibForUser(user) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } resp := models.Nested{ User: *userModel, Books: books, } c.JSON(http.StatusOK, resp) } package handlers import ( \"books/internal/api/helpers\" \"github.com/gin-gonic/gin\" \"net/http\" \"strconv\" ) func (h *Handler) CreateRequest(c *gin.Context) { requester := c.Query(\"requester\") var req helpers.CreateRequestReq err := c.BindJSON(&req) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, helpers.NewJSONErr(err)) return } err = h.storage.CreateRequest(requester, req.Owner, req.BookID) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatus(http.StatusOK) } func (h *Handler) GetRequestsList(c *gin.Context) { user := c.Query(\"login\") list, err := h.storage.GetRequestsList(user) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.JSON(http.StatusOK, &list) } func (h *Handler) AcceptRequest(c *gin.Context) { id := c.Query(\"id\") idInt, _ := strconv.Atoi(id) err := h.storage.AcceptRequest(idInt) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatus(http.StatusOK) }","title":"Lab 1"},{"location":"lab_1/#_1","text":"","title":"\u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u043f\u0440\u043e\u0435\u043a\u0442\u0430"},{"location":"lab_1/#_2","text":"","title":"\u041c\u0438\u0433\u0440\u0430\u0446\u0438\u0438 \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445"},{"location":"lab_1/#_3","text":"","title":"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f"},{"location":"lab_1/#_4","text":"func (s *Server) RegisterUser(c *gin.Context) { login := c.Query(\"login\") password := c.Query(\"password\") err := s.storage.CreateUser(login, password) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatus(http.StatusOK) } func (s *Server) AuthUser(c *gin.Context) { login := c.Query(\"login\") password := c.Query(\"password\") res, err := s.storage.AuthUser(login, password) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } if res { token, err := s.tokenator.Generate(login) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatusJSON(http.StatusOK, gin.H{\"token\": token}) return } else { c.AbortWithStatusJSON(http.StatusBadRequest, helpers.NewJSONErr(errs.WrongCredentials)) return } } func (s *Server) AuthMW(c *gin.Context) { token := c.GetHeader(\"token\") res, login := s.tokenator.Check(token) if res { c.AddParam(\"login\", login) c.Next() } else { c.AbortWithStatus(http.StatusUnauthorized) return } } package handlers import ( \"books/internal/api/helpers\" \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\" \"strconv\" ) func (h *Handler) CreateBook(c *gin.Context) { author := c.Query(\"author\") name := c.Query(\"name\") err := h.storage.CreateBook(author, name) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatus(http.StatusOK) } func (h *Handler) GetBooks(c *gin.Context) { res, err := h.storage.GetBooks() if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.IndentedJSON(http.StatusOK, res) } func (h *Handler) AddBookToLib(c *gin.Context) { user := c.Query(\"login\") bookStr := c.Query(\"bookID\") bookID, _ := strconv.Atoi(bookStr) fmt.Println(\"book id: \", bookID) err := h.storage.AddBookToLib(user, bookID) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatus(http.StatusOK) } func (h *Handler) GetUserLib(c *gin.Context) { user := c.Query(\"user\") userModel, err := h.storage.GetUser(user) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } books, err := h.storage.GetLibForUser(user) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } resp := models.Nested{ User: *userModel, Books: books, } c.JSON(http.StatusOK, resp) } package handlers import ( \"books/internal/api/helpers\" \"github.com/gin-gonic/gin\" \"net/http\" \"strconv\" ) func (h *Handler) CreateRequest(c *gin.Context) { requester := c.Query(\"requester\") var req helpers.CreateRequestReq err := c.BindJSON(&req) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, helpers.NewJSONErr(err)) return } err = h.storage.CreateRequest(requester, req.Owner, req.BookID) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatus(http.StatusOK) } func (h *Handler) GetRequestsList(c *gin.Context) { user := c.Query(\"login\") list, err := h.storage.GetRequestsList(user) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.JSON(http.StatusOK, &list) } func (h *Handler) AcceptRequest(c *gin.Context) { id := c.Query(\"id\") idInt, _ := strconv.Atoi(id) err := h.storage.AcceptRequest(idInt) if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, helpers.NewJSONErr(err)) return } c.AbortWithStatus(http.StatusOK) }","title":"\u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b"},{"location":"lab_2/","text":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u041f\u0440\u0438 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0432\u0441\u0435\u0445 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 \u0432 \u0434\u0430\u043d\u043d\u043e\u043c \u0437\u0430\u0434\u0430\u043d\u0438\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043b\u0430\u0441\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u0442\u0435\u0433\u0438\u044f: \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u0432\u0432\u0435\u0441\u0442\u0438 \u0447\u0438\u0441\u043b\u043e. \u0414\u0430\u043b\u0435\u0435 \u0447\u0438\u0441\u043b\u043e\u0432\u043e\u0439 \u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043e\u043a \u0440\u0430\u0437\u0431\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u0434\u0430\u043d\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043a\u043e\u0432 \u0438 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u043e\u0442\u043e\u043a \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u043a\u0430\u0436\u0434\u044b\u0439 \u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043e\u043a. \u0417\u0430\u0442\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0441\u0443\u043c\u043c\u0438\u0440\u0443\u0435\u0442\u0441\u044f threading import threading total_sum = 0 def calculate_sum(left: int, right: int): global total_sum local_sum = 0 for i in range(left, right+1): local_sum += i total_sum += local_sum def main(): n = int(input(\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u0438\u0437\u043c\u0430 \")) threads = [] top_border = 1000000 step = top_border // n for i in range(1, n+1): right_border = step*i left_border = right_border-step+1 t = threading.Thread(target=calculate_sum, args=(left_border, right_border,)) threads.append(t) t.start() for t in threads: t.join() print(\"Total sum equal: \", total_sum) main() processing import multiprocessing as mp def calculate_sum(q, left: int, right: int): local_sum = 0 for i in range(left, right + 1): local_sum += i total_sum = q.get() total_sum += local_sum q.put(total_sum) def main(): n = int(input(\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u0438\u0437\u043c\u0430 \")) processes = [] top_border = 1000000 step = top_border // n q = mp.Queue() q.put(0) for i in range(1, n+1): right_border = step*i left_border = right_border-step+1 p = mp.Process(target=calculate_sum, args=(q, left_border, right_border,)) processes.append(p) p.start() for p in processes: p.join() total_sum = q.get() print(\"Total sum equal: \", total_sum) if __name__ == '__main__': main() async import asyncio total_sum = 0 async def calculate_sum(left: int, right: int): global total_sum local_sum = 0 for i in range(left, right + 1): local_sum += i total_sum += local_sum async def main(): n = int(input(\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u0438\u0437\u043c\u0430 \")) top_border = 1000000 step = top_border // n for i in range(1, n + 1): right_border = step * i left_border = right_border - step + 1 t = asyncio.create_task(calculate_sum(left_border, right_border)) await t print(\"Total sum equal: \", total_sum) asyncio.run(main()) \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 \u0412 \u0434\u0430\u043d\u043d\u043e\u043c \u0437\u0430\u0434\u0430\u043d\u0438\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043b\u0441\u044f \u043f\u0430\u0442\u0442\u0435\u0440\u043d \"\u043f\u0443\u043b \u043f\u043e\u0442\u043e\u043a\u043e\u0432\". \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0442\u0430\u043a \u0436\u0435 \u0432\u0432\u043e\u0434\u0438\u0442 \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u043f\u0430\u0440\u0440\u0430\u043b\u043b\u0435\u043b\u0438\u0437\u043c\u0430. \u0421\u043e\u0437\u0434\u0430\u0435\u0442\u0441\u044f \u0441\u043e\u043e\u0442. \u0447\u0438\u0441\u043b\u043e \u043f\u043e\u0442\u043e\u043a\u043e\u0432 \u0438 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043d\u0438\u0445 \u0434\u0435\u043b\u0430\u0435\u0442 \u0441\u0432\u043e\u044e \u0447\u0430\u0441\u0442\u044c \u0440\u0430\u0431\u043e\u0442\u044b threading import threading as t import requests from bs4 import BeautifulSoup database = {} work = [ \"https://www.gismeteo.ru/diary/4079/2023/2/\", \"https://www.w3schools.com/html/html_basic.asp\", \"https://www.javatpoint.com/simple-html-pages\" ] lock = t.Lock() def parse_and_save(url): global database headers = { 'User-Agent': 'My User Agent 1.0', # \u043c\u043d\u043e\u0433\u0438\u0435 \u0441\u0430\u0439\u0442\u044b \u043d\u0435 \u0434\u0430\u044e\u0442 \u0441\u0435\u0431\u044f \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0431\u043e\u0442\u0430\u043c } response = requests.get(url, headers=headers) page = response.text soup = BeautifulSoup(page) title = soup.title.text database[url] = title def acquire_work(): global work while True: lock.acquire() if work: url = work[0] work.pop(0) lock.release() parse_and_save(url) else: lock.release() return def main(n: int): workers = [] for _ in range(n): worker = t.Thread(target=acquire_work) workers.append(worker) worker.start() for w in workers: w.join() print(database) main(3) processing from multiprocessing import Pool import requests from bs4 import BeautifulSoup def parse_and_save(url): headers = { 'User-Agent': 'My User Agent 1.0', # \u043c\u043d\u043e\u0433\u0438\u0435 \u0441\u0430\u0439\u0442\u044b \u043d\u0435 \u0434\u0430\u044e\u0442 \u0441\u0435\u0431\u044f \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0431\u043e\u0442\u0430\u043c } response = requests.get(url, headers=headers) page = response.text soup = BeautifulSoup(page) title = soup.title.text return url, title if __name__ == \"__main__\": n = 3 with Pool(processes=n) as pool: work = [ \"https://www.gismeteo.ru/diary/4079/2023/2/\", \"https://www.w3schools.com/html/html_basic.asp\", \"https://www.javatpoint.com/simple-html-pages\" ] result = pool.map(parse_and_save, work) print(result) async import asyncio import threading as t import requests from bs4 import BeautifulSoup database = {} work = [ \"https://www.gismeteo.ru/diary/4079/2023/2/\", \"https://www.w3schools.com/html/html_basic.asp\", \"https://www.javatpoint.com/simple-html-pages\" ] lock = asyncio.Lock() def parse_and_save(url): global database headers = { 'User-Agent': 'My User Agent 1.0', # \u043c\u043d\u043e\u0433\u0438\u0435 \u0441\u0430\u0439\u0442\u044b \u043d\u0435 \u0434\u0430\u044e\u0442 \u0441\u0435\u0431\u044f \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0431\u043e\u0442\u0430\u043c } response = requests.get(url, headers=headers) page = response.text soup = BeautifulSoup(page) title = soup.title.text database[url] = title async def acquire_work(): global work while True: await lock.acquire() if work: url = work[0] work.pop(0) lock.release() parse_and_save(url) else: lock.release() return async def main(n: int): for _ in range(n): worker = asyncio.create_task(acquire_work()) await worker print(database) asyncio.run(main(3))","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"lab_2/#1","text":"\u041f\u0440\u0438 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0432\u0441\u0435\u0445 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 \u0432 \u0434\u0430\u043d\u043d\u043e\u043c \u0437\u0430\u0434\u0430\u043d\u0438\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043b\u0430\u0441\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u0442\u0435\u0433\u0438\u044f: \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u0432\u0432\u0435\u0441\u0442\u0438 \u0447\u0438\u0441\u043b\u043e. \u0414\u0430\u043b\u0435\u0435 \u0447\u0438\u0441\u043b\u043e\u0432\u043e\u0439 \u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043e\u043a \u0440\u0430\u0437\u0431\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u0434\u0430\u043d\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043a\u043e\u0432 \u0438 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u043e\u0442\u043e\u043a \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u043a\u0430\u0436\u0434\u044b\u0439 \u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043e\u043a. \u0417\u0430\u0442\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0441\u0443\u043c\u043c\u0438\u0440\u0443\u0435\u0442\u0441\u044f","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"lab_2/#threading","text":"import threading total_sum = 0 def calculate_sum(left: int, right: int): global total_sum local_sum = 0 for i in range(left, right+1): local_sum += i total_sum += local_sum def main(): n = int(input(\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u0438\u0437\u043c\u0430 \")) threads = [] top_border = 1000000 step = top_border // n for i in range(1, n+1): right_border = step*i left_border = right_border-step+1 t = threading.Thread(target=calculate_sum, args=(left_border, right_border,)) threads.append(t) t.start() for t in threads: t.join() print(\"Total sum equal: \", total_sum) main()","title":"threading"},{"location":"lab_2/#processing","text":"import multiprocessing as mp def calculate_sum(q, left: int, right: int): local_sum = 0 for i in range(left, right + 1): local_sum += i total_sum = q.get() total_sum += local_sum q.put(total_sum) def main(): n = int(input(\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u0438\u0437\u043c\u0430 \")) processes = [] top_border = 1000000 step = top_border // n q = mp.Queue() q.put(0) for i in range(1, n+1): right_border = step*i left_border = right_border-step+1 p = mp.Process(target=calculate_sum, args=(q, left_border, right_border,)) processes.append(p) p.start() for p in processes: p.join() total_sum = q.get() print(\"Total sum equal: \", total_sum) if __name__ == '__main__': main()","title":"processing"},{"location":"lab_2/#async","text":"import asyncio total_sum = 0 async def calculate_sum(left: int, right: int): global total_sum local_sum = 0 for i in range(left, right + 1): local_sum += i total_sum += local_sum async def main(): n = int(input(\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u0438\u0437\u043c\u0430 \")) top_border = 1000000 step = top_border // n for i in range(1, n + 1): right_border = step * i left_border = right_border - step + 1 t = asyncio.create_task(calculate_sum(left_border, right_border)) await t print(\"Total sum equal: \", total_sum) asyncio.run(main())","title":"async"},{"location":"lab_2/#2","text":"\u0412 \u0434\u0430\u043d\u043d\u043e\u043c \u0437\u0430\u0434\u0430\u043d\u0438\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043b\u0441\u044f \u043f\u0430\u0442\u0442\u0435\u0440\u043d \"\u043f\u0443\u043b \u043f\u043e\u0442\u043e\u043a\u043e\u0432\". \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0442\u0430\u043a \u0436\u0435 \u0432\u0432\u043e\u0434\u0438\u0442 \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u043f\u0430\u0440\u0440\u0430\u043b\u043b\u0435\u043b\u0438\u0437\u043c\u0430. \u0421\u043e\u0437\u0434\u0430\u0435\u0442\u0441\u044f \u0441\u043e\u043e\u0442. \u0447\u0438\u0441\u043b\u043e \u043f\u043e\u0442\u043e\u043a\u043e\u0432 \u0438 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043d\u0438\u0445 \u0434\u0435\u043b\u0430\u0435\u0442 \u0441\u0432\u043e\u044e \u0447\u0430\u0441\u0442\u044c \u0440\u0430\u0431\u043e\u0442\u044b","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2"},{"location":"lab_2/#threading_1","text":"import threading as t import requests from bs4 import BeautifulSoup database = {} work = [ \"https://www.gismeteo.ru/diary/4079/2023/2/\", \"https://www.w3schools.com/html/html_basic.asp\", \"https://www.javatpoint.com/simple-html-pages\" ] lock = t.Lock() def parse_and_save(url): global database headers = { 'User-Agent': 'My User Agent 1.0', # \u043c\u043d\u043e\u0433\u0438\u0435 \u0441\u0430\u0439\u0442\u044b \u043d\u0435 \u0434\u0430\u044e\u0442 \u0441\u0435\u0431\u044f \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0431\u043e\u0442\u0430\u043c } response = requests.get(url, headers=headers) page = response.text soup = BeautifulSoup(page) title = soup.title.text database[url] = title def acquire_work(): global work while True: lock.acquire() if work: url = work[0] work.pop(0) lock.release() parse_and_save(url) else: lock.release() return def main(n: int): workers = [] for _ in range(n): worker = t.Thread(target=acquire_work) workers.append(worker) worker.start() for w in workers: w.join() print(database) main(3)","title":"threading"},{"location":"lab_2/#processing_1","text":"from multiprocessing import Pool import requests from bs4 import BeautifulSoup def parse_and_save(url): headers = { 'User-Agent': 'My User Agent 1.0', # \u043c\u043d\u043e\u0433\u0438\u0435 \u0441\u0430\u0439\u0442\u044b \u043d\u0435 \u0434\u0430\u044e\u0442 \u0441\u0435\u0431\u044f \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0431\u043e\u0442\u0430\u043c } response = requests.get(url, headers=headers) page = response.text soup = BeautifulSoup(page) title = soup.title.text return url, title if __name__ == \"__main__\": n = 3 with Pool(processes=n) as pool: work = [ \"https://www.gismeteo.ru/diary/4079/2023/2/\", \"https://www.w3schools.com/html/html_basic.asp\", \"https://www.javatpoint.com/simple-html-pages\" ] result = pool.map(parse_and_save, work) print(result)","title":"processing"},{"location":"lab_2/#async_1","text":"import asyncio import threading as t import requests from bs4 import BeautifulSoup database = {} work = [ \"https://www.gismeteo.ru/diary/4079/2023/2/\", \"https://www.w3schools.com/html/html_basic.asp\", \"https://www.javatpoint.com/simple-html-pages\" ] lock = asyncio.Lock() def parse_and_save(url): global database headers = { 'User-Agent': 'My User Agent 1.0', # \u043c\u043d\u043e\u0433\u0438\u0435 \u0441\u0430\u0439\u0442\u044b \u043d\u0435 \u0434\u0430\u044e\u0442 \u0441\u0435\u0431\u044f \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0431\u043e\u0442\u0430\u043c } response = requests.get(url, headers=headers) page = response.text soup = BeautifulSoup(page) title = soup.title.text database[url] = title async def acquire_work(): global work while True: await lock.acquire() if work: url = work[0] work.pop(0) lock.release() parse_and_save(url) else: lock.release() return async def main(n: int): for _ in range(n): worker = asyncio.create_task(acquire_work()) await worker print(database) asyncio.run(main(3))","title":"async"},{"location":"lab_3/","text":"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f Rabbit: url: amqp://guest:guest@rabbit:5672/ Server: host: api port: 8080 Postgres: host: 'postgres' port: '5432' username: 'root' password: 'secret' database: 'parsing' Compose-\u0444\u0430\u0439\u043b version: \"3.9\" services: postgres: image: postgres:16 ports: - \"5432:5432\" environment: - POSTGRES_USER=root - POSTGRES_PASSWORD=secret - POSTGRES_DB=parsing api: image: api:latest ports: - \"8080:8080\" depends_on: - postgres rabbit: image: rabbitmq:3.13-management ports: - \"5672:5672\" - \"15672:15672\" depends_on: - api worker: image: worker:latest depends_on: - rabbit API package server import ( \"context\" \"fmt\" \"github.com/gin-gonic/gin\" amqp \"github.com/rabbitmq/amqp091-go\" \"net/http\" \"time\" ) func (s *Server) parseHandler(c *gin.Context) { url := c.Query(\"url\") fmt.Println(\"url:\", url) conn, err := amqp.Dial(s.cfg.URL) if err != nil { c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{\"rabbit connecting error\": err.Error()}) return } defer conn.Close() ch, err := conn.Channel() if err != nil { c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{\"open rabbit channel err\": err.Error()}) return } q, err := ch.QueueDeclare( \"parsing\", // name false, // durable false, // delete when unused false, // exclusive false, // no-wait nil, // arguments ) if err != nil { c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{\"open queue err\": err.Error()}) return } ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() err = ch.PublishWithContext(ctx, \"\", // exchange q.Name, // routing key false, // mandatory false, // immediate amqp.Publishing{ ContentType: \"text/plain\", Body: []byte(url), }) if err != nil { c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{\"publish task err\": err.Error()}) return } c.AbortWithStatus(http.StatusOK) } Worker package main import ( \"errors\" \"fmt\" amqp \"github.com/rabbitmq/amqp091-go\" \"golang.org/x/net/html\" \"lab3/config\" \"lab3/internal/storage\" \"log\" \"net/http\" \"strings\" \"time\" ) func main() { cfg := config.MustLoad() fmt.Println(cfg) s := storage.New(cfg) s.Connect() // \u0417\u0430\u0431\u0440\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 Rabbit time.Sleep(5 * time.Second) conn, err := amqp.Dial(cfg.URL) if err != nil { log.Fatalf(\"Error connecting to RabbitMQ: %s\", err) } defer conn.Close() ch, err := conn.Channel() failOnError(err, \"Failed to open a channel\") defer ch.Close() q, err := ch.QueueDeclare( \"parsing\", // name false, // durable false, // delete when unused false, // exclusive false, // no-wait nil, // arguments ) failOnError(err, \"Failed to declare a queue\") msgs, err := ch.Consume( q.Name, // queue \"\", // consumer true, // auto-ack false, // exclusive false, // no-local false, // no-wait nil, // args ) failOnError(err, \"Failed to register a consumer\") var forever chan struct{} go func() { for d := range msgs { url := string(d.Body) title, err := parsePage(url) if err != nil { log.Println(err) } else { err = s.SaveTitle(url, title) if err != nil { log.Println(err) } } } }() log.Printf(\" [*] Waiting for messages. To exit press CTRL+C\") <-forever } func failOnError(err error, msg string) { if err != nil { log.Panicf(\"%s: %s\", msg, err) } } func parsePage(url string) (string, error) { resp, _ := http.Get(url) defer resp.Body.Close() z := html.NewTokenizer(resp.Body) for { tt := z.Next() if tt == html.ErrorToken { break } t := z.Token() if t.Type == html.StartTagToken && t.Data == \"title\" { if z.Next() == html.TextToken { title := strings.TrimSpace(z.Token().Data) return title, nil } } } return \"\", errors.New(\"Title not found\") }","title":"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f"},{"location":"lab_3/#_1","text":"Rabbit: url: amqp://guest:guest@rabbit:5672/ Server: host: api port: 8080 Postgres: host: 'postgres' port: '5432' username: 'root' password: 'secret' database: 'parsing'","title":"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f"},{"location":"lab_3/#compose-","text":"version: \"3.9\" services: postgres: image: postgres:16 ports: - \"5432:5432\" environment: - POSTGRES_USER=root - POSTGRES_PASSWORD=secret - POSTGRES_DB=parsing api: image: api:latest ports: - \"8080:8080\" depends_on: - postgres rabbit: image: rabbitmq:3.13-management ports: - \"5672:5672\" - \"15672:15672\" depends_on: - api worker: image: worker:latest depends_on: - rabbit","title":"Compose-\u0444\u0430\u0439\u043b"},{"location":"lab_3/#api","text":"package server import ( \"context\" \"fmt\" \"github.com/gin-gonic/gin\" amqp \"github.com/rabbitmq/amqp091-go\" \"net/http\" \"time\" ) func (s *Server) parseHandler(c *gin.Context) { url := c.Query(\"url\") fmt.Println(\"url:\", url) conn, err := amqp.Dial(s.cfg.URL) if err != nil { c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{\"rabbit connecting error\": err.Error()}) return } defer conn.Close() ch, err := conn.Channel() if err != nil { c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{\"open rabbit channel err\": err.Error()}) return } q, err := ch.QueueDeclare( \"parsing\", // name false, // durable false, // delete when unused false, // exclusive false, // no-wait nil, // arguments ) if err != nil { c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{\"open queue err\": err.Error()}) return } ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() err = ch.PublishWithContext(ctx, \"\", // exchange q.Name, // routing key false, // mandatory false, // immediate amqp.Publishing{ ContentType: \"text/plain\", Body: []byte(url), }) if err != nil { c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{\"publish task err\": err.Error()}) return } c.AbortWithStatus(http.StatusOK) }","title":"API"},{"location":"lab_3/#worker","text":"package main import ( \"errors\" \"fmt\" amqp \"github.com/rabbitmq/amqp091-go\" \"golang.org/x/net/html\" \"lab3/config\" \"lab3/internal/storage\" \"log\" \"net/http\" \"strings\" \"time\" ) func main() { cfg := config.MustLoad() fmt.Println(cfg) s := storage.New(cfg) s.Connect() // \u0417\u0430\u0431\u0440\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 Rabbit time.Sleep(5 * time.Second) conn, err := amqp.Dial(cfg.URL) if err != nil { log.Fatalf(\"Error connecting to RabbitMQ: %s\", err) } defer conn.Close() ch, err := conn.Channel() failOnError(err, \"Failed to open a channel\") defer ch.Close() q, err := ch.QueueDeclare( \"parsing\", // name false, // durable false, // delete when unused false, // exclusive false, // no-wait nil, // arguments ) failOnError(err, \"Failed to declare a queue\") msgs, err := ch.Consume( q.Name, // queue \"\", // consumer true, // auto-ack false, // exclusive false, // no-local false, // no-wait nil, // args ) failOnError(err, \"Failed to register a consumer\") var forever chan struct{} go func() { for d := range msgs { url := string(d.Body) title, err := parsePage(url) if err != nil { log.Println(err) } else { err = s.SaveTitle(url, title) if err != nil { log.Println(err) } } } }() log.Printf(\" [*] Waiting for messages. To exit press CTRL+C\") <-forever } func failOnError(err error, msg string) { if err != nil { log.Panicf(\"%s: %s\", msg, err) } } func parsePage(url string) (string, error) { resp, _ := http.Get(url) defer resp.Body.Close() z := html.NewTokenizer(resp.Body) for { tt := z.Next() if tt == html.ErrorToken { break } t := z.Token() if t.Type == html.StartTagToken && t.Data == \"title\" { if z.Next() == html.TextToken { title := strings.TrimSpace(z.Token().Data) return title, nil } } } return \"\", errors.New(\"Title not found\") }","title":"Worker"}]}